"""
Professional Referencing & Rig UI - Script Injection Module
Handles detection, rewriting, and isolation of rig UI scripts
"""

import bpy


class RigUIScriptInjector:
    """Handles all rig UI script detection and modification"""
    
    @staticmethod
    def find_rig_ui_script(armature_obj):
        """
        Find the rig_ui.py script associated with an armature
        
        Args:
            armature_obj: Armature object to find script for
            
        Returns:
            bpy.types.Text or None
        """
        if not armature_obj or armature_obj.type != 'ARMATURE':
            return None
        
        # Check if armature already has a custom script assigned
        if "proref_rig_ui" in armature_obj:
            script_name = armature_obj["proref_rig_ui"]
            if script_name in bpy.data.texts:
                return bpy.data.texts[script_name]
        
        # Search for rig_ui scripts in linked library
        library = armature_obj.data.library if armature_obj.data else None
        
        for text in bpy.data.texts:
            # Match any script with "rig_ui" in name from same library
            if "rig_ui" in text.name.lower():
                if text.library == library:
                    return text
        
        # Fallback: search for scripts that reference this armature by name
        armature_name = armature_obj.name
        for text in bpy.data.texts:
            if "rig_ui" in text.name.lower():
                if armature_name in text.as_string():
                    return text
        
        return None
    
    @staticmethod
    def create_isolated_script(original_script, armature_name, unique_id):
        """
        Create an isolated copy of a rig UI script for a specific armature
        
        Args:
            original_script: The source rig_ui.py text block
            armature_name: Name of the target armature object
            unique_id: Unique identifier for this instance
            
        Returns:
            bpy.types.Text: The new isolated script
        """
        # Generate unique script name
        new_script_name = f"rig_ui_{unique_id}.py"
        
        # Check if script already exists
        if new_script_name in bpy.data.texts:
            return bpy.data.texts[new_script_name]
        
        # Create copy
        new_script = original_script.copy()
        new_script.name = new_script_name
        
        # Rewrite script content for this specific armature
        original_code = new_script.as_string()
        modified_code = RigUIScriptInjector.inject_armature_context(
            original_code, 
            armature_name
        )
        
        # Replace content
        new_script.clear()
        new_script.write(modified_code)
        
        return new_script
    
    @staticmethod
    def inject_armature_context(script_code, armature_name):
        """
        Rewrite rig_ui.py to target a specific armature object
        
        This prevents multiple rig UI scripts from interfering with each other
        by replacing global context references with specific object lookups.
        
        Args:
            script_code: Original script source code
            armature_name: Name of the target armature
            
        Returns:
            str: Modified script source code
        """
        
        # Common patterns in rig UI scripts that need replacement
        replacements = [
            # Replace direct context.active_object references
            (
                "context.active_object",
                f"bpy.data.objects.get('{armature_name}', context.active_object)"
            ),
            # Replace bpy.context.active_object references
            (
                "bpy.context.active_object",
                f"bpy.data.objects.get('{armature_name}', bpy.context.active_object)"
            ),
            # Replace context.object references
            (
                "context.object",
                f"bpy.data.objects.get('{armature_name}', context.object)"
            ),
            # Replace C.active_object shorthand (common in Rigify)
            (
                "C.active_object",
                f"bpy.data.objects.get('{armature_name}', C.active_object)"
            ),
            # Replace C.object shorthand
            (
                "C.object",
                f"bpy.data.objects.get('{armature_name}', C.object)"
            ),
        ]
        
        modified = script_code
        for old_pattern, new_pattern in replacements:
            modified = modified.replace(old_pattern, new_pattern)
        
        # Inject armature name as a constant at the top
        header = f"""# Auto-generated by Professional Referencing addon
# Target Armature: {armature_name}
_PROREF_TARGET_ARMATURE = '{armature_name}'

"""
        
        # Add header after imports
        import_end = modified.find('\n\n')
        if import_end != -1:
            modified = modified[:import_end] + '\n' + header + modified[import_end:]
        else:
            modified = header + modified
        
        return modified
    
    @staticmethod
    def execute_isolated_script(armature_obj, script_text):
        """
        Execute a rig UI script with proper context isolation
        
        Args:
            armature_obj: The armature to execute the script for
            script_text: The bpy.types.Text script to execute
            
        Returns:
            tuple: (success: bool, error_message: str or None)
        """
        # Store original active object
        original_active = bpy.context.view_layer.objects.active
        
        try:
            # Set target armature as active
            bpy.context.view_layer.objects.active = armature_obj
            
            # Create isolated namespace
            namespace = {
                "__name__": "__main__",
                "__file__": script_text.name,
                "bpy": bpy,
                "C": bpy.context,
                "D": bpy.data,
                "_PROREF_ARMATURE": armature_obj,
            }
            
            # Execute script
            exec(script_text.as_string(), namespace)
            
            return (True, None)
            
        except Exception as e:
            import traceback
            error_msg = f"Script execution failed: {str(e)}\n{traceback.format_exc()}"
            return (False, error_msg)
            
        finally:
            # Always restore original active object
            bpy.context.view_layer.objects.active = original_active
    
    @staticmethod
    def validate_script_safety(script_text):
        """
        Check if a rig UI script uses patterns that might cause issues
        
        Args:
            script_text: The script to validate
            
        Returns:
            tuple: (is_safe: bool, warnings: list of str)
        """
        code = script_text.as_string()
        warnings = []
        
        # Check for dangerous patterns
        dangerous_patterns = [
            ("bpy.ops.wm.save", "Script tries to save the file"),
            ("bpy.ops.wm.quit", "Script tries to quit Blender"),
            ("os.system", "Script uses system commands"),
            ("subprocess", "Script uses subprocess module"),
            ("__import__", "Script uses dynamic imports"),
            ("eval(", "Script uses eval()"),
            ("exec(", "Script uses exec()"),
        ]
        
        # Check for warning patterns (not critical but worth noting)
        warning_patterns = [
            ("bpy.context.selected_objects", "Script relies on selection (may conflict)"),
            ("for obj in bpy.data.objects", "Script iterates all objects (performance risk)"),
            ("bpy.ops.object.select_all", "Script modifies selection state"),
            ("import os", "Script imports os module"),
        ]
        
        # Check dangerous patterns
        critical_issues = []
        for pattern, warning in dangerous_patterns:
            if pattern in code:
                critical_issues.append(warning)
        
        # Check warning patterns
        for pattern, warning in warning_patterns:
            if pattern in code:
                warnings.append(warning)
        
        # Script is "safe" if no critical issues found
        is_safe = len(critical_issues) == 0
        
        # Combine all issues for reporting
        all_warnings = critical_issues + warnings
        
        return (is_safe, all_warnings)
